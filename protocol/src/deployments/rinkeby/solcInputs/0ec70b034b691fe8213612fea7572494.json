{
  "language": "Solidity",
  "sources": {
    "contracts/0xSplits/interfaces/ISplitMain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\n\n/**\n * @title ISplitMain\n * @author 0xSplits <will@0xSplits.xyz>\n */\ninterface ISplitMain {\n  /**\n   * FUNCTIONS\n   */\n\n  function walletImplementation() external returns (address);\n\n  function createSplit(\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee,\n    address controller\n  ) external returns (address);\n\n  function predictImmutableSplitAddress(\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee\n  ) external view returns (address);\n\n  function updateSplit(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee\n  ) external;\n\n  function transferControl(address split, address newController) external;\n\n  function cancelControlTransfer(address split) external;\n\n  function acceptControl(address split) external;\n\n  function makeSplitImmutable(address split) external;\n\n  function distributeETH(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee,\n    address distributionAddress\n  ) external;\n\n  function distributeERC20(\n    address split,\n    ERC20 token,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee,\n    address distributionAddress\n  ) external;\n\n  function withdraw(\n    address account,\n    bool eth,\n    ERC20[] calldata tokens\n  ) external;\n\n  /**\n   * EVENTS\n   */\n\n  /** @notice emitted after each successful split creation\n   *  @param split Address of the created split\n   */\n  event CreateSplit(address indexed split);\n\n  /** @notice emitted after each successful split update\n   *  @param split Address of the updated split\n   */\n  event UpdateSplit(address indexed split);\n\n  /** @notice emitted after each initiated split control transfer\n   *  @param split Address of the split control transfer was initiated for\n   *  @param newPotentialController Address of the split's new potential controller\n   */\n  event InitiateControlTransfer(\n    address indexed split,\n    address indexed newPotentialController\n  );\n\n  /** @notice emitted after each canceled split control transfer\n   *  @param split Address of the split control transfer was canceled for\n   */\n  event CancelControlTransfer(address indexed split);\n\n  /** @notice emitted after each successful split control transfer\n   *  @param split Address of the split control was transferred for\n   *  @param previousController Address of the split's previous controller\n   *  @param newController Address of the split's new controller\n   */\n  event ControlTransfer(\n    address indexed split,\n    address indexed previousController,\n    address indexed newController\n  );\n\n  /** @notice emitted after each successful ETH balance split\n   *  @param split Address of the split that distributed its balance\n   *  @param amount Amount of ETH distributed\n   *  @param distributionAddress Address to credit distribution fee to\n   */\n  event DistributeETH(\n    address indexed split,\n    uint256 amount,\n    address indexed distributionAddress\n  );\n\n  /** @notice emitted after each successful ERC20 balance split\n   *  @param split Address of the split that distributed its balance\n   *  @param token Address of ERC20 distributed\n   *  @param amount Amount of ERC20 distributed\n   *  @param distributionAddress Address to credit distribution fee to\n   */\n  event DistributeERC20(\n    address indexed split,\n    ERC20 indexed token,\n    uint256 amount,\n    address indexed distributionAddress\n  );\n\n  /** @notice emitted after each successful withdrawal\n   *  @param account Address that funds were withdrawn to\n   *  @param eth Boolean for whether ETH was distributed\n   *  @param tokens Addresses of ERC20s distributed\n   *  @param amounts Amounts of ETH/ERC20 distributed (if ETH was distributed (`eth`),\n   *  will be first in the array Remaining array matches order of `tokens`)\n   */\n  event Withdrawal(\n    address indexed account,\n    bool eth,\n    ERC20[] tokens,\n    uint256[] amounts\n  );\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/0xSplits/SplitWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ISplitMain} from './interfaces/ISplitMain.sol';\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\nimport {SafeTransferLib} from '@rari-capital/solmate/src/utils/SafeTransferLib.sol';\n\n/**\n * ERRORS\n */\n\n/// @notice Unauthorized sender\nerror Unauthorized();\n\n/**\n * @title SplitWallet\n * @author 0xSplits <will@0xSplits.xyz>\n * @notice The implementation logic for `SplitProxy`.\n * @dev `SplitProxy` handles `receive()` itself to avoid the gas cost with `DELEGATECALL`.\n */\ncontract SplitWallet {\n  using SafeTransferLib for address;\n  using SafeTransferLib for ERC20;\n\n  /**\n   * EVENTS\n   */\n\n  /** @notice emitted after each successful ETH transfer to proxy\n   *  @param split Address of the split that received ETH\n   *  @param amount Amount of ETH received\n   */\n  event ReceiveETH(address indexed split, uint256 amount);\n\n  /**\n   * STORAGE\n   */\n\n  /**\n   * STORAGE - CONSTANTS & IMMUTABLES\n   */\n\n  /// @notice address of SplitMain for split distributions & EOA/SC withdrawals\n  ISplitMain public immutable splitMain;\n\n  /**\n   * MODIFIERS\n   */\n\n  /// @notice Reverts if the sender isn't SplitMain\n  modifier onlySplitMain() {\n    if (msg.sender != address(splitMain)) revert Unauthorized();\n    _;\n  }\n\n  /**\n   * CONSTRUCTOR\n   */\n\n  constructor() {\n    splitMain = ISplitMain(msg.sender);\n  }\n\n  /**\n   * FUNCTIONS - PUBLIC & EXTERNAL\n   */\n\n  /** @notice Sends amount `amount` of ETH in proxy to SplitMain\n   *  @param amount Amount to send\n   */\n  function sendETHToMain(uint256 amount) external onlySplitMain() {\n    address(splitMain).safeTransferETH(amount);\n  }\n\n  /** @notice Sends amount `amount` of ERC20 `token` in proxy to SplitMain\n   *  @param token Token to send\n   *  @param amount Amount to send\n   */\n  function sendERC20ToMain(ERC20 token, uint256 amount)\n    external\n    onlySplitMain()\n  {\n    token.safeTransfer(address(splitMain), amount);\n  }\n}\n"
    },
    "@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "contracts/0xSplits/SplitMain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ISplitMain} from './interfaces/ISplitMain.sol';\nimport {SplitWallet} from './SplitWallet.sol';\nimport {Clones} from './libraries/Clones.sol';\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\nimport {SafeTransferLib} from '@rari-capital/solmate/src/utils/SafeTransferLib.sol';\n\n/**\n                                                    ,s# ## mp\n                                                ;# ########### #p\n                                           ,s@ ######## B ########  m,\n                                       ,s# ####### W2`      l% ######## #p\n                                  ,s# ######## K*               |8 ######## #m,\n                              ,s# ######## f^                        7  ######## mp\n                          ;# ######## b|                                 |8 #######\n                     ,s  ######## b|                                   ,s  #########\n                 ,m# ####### 8T`                                   ;# ##############\n            ,;# ######## B7                                   ,s  ######## K7  @####\n        ,s# ######## T\"                                   ,s  ######## T^      @####\n    ,# ######## W|                                    ;# ######## W2           @####\n    #########p                                   ,s  ######## B\\               @####\n    ########### #p                           ,## ##########\"                   @####\n    ###### ########  m,                 ,;# ######## B@####                    @####\n    #####   ^l ######### Qp         ,s# ######## b^   @####                    @####\n    #####        |8 ######## #m,;# ######## 8|        @####                    @####\n    #####            |8 ############### T|            @####                    @####\n    #####                '3  ######## mp              @####                    @####\n    #####                     |8 ######## #m,         @####                    @####\n    #####                          j  ######## m,     @####                    @####\n    #####                              |8 ######## #p @####                    @####\n    #####                                  ^7 #############                    @####\n    ##### Qp                                    |Y ########                    @####\n    %######## #p,                                   |8@####                    @####\n       j  ######## mp                                 @####                    @####\n           \"Y ######## #p                             @####                    @####\n               ^7 ########  m,                        @####                    @####\n                    l% ######## #p                    @####                    @####\n                        |8 ######## #m,               @####               ,s# ######\n                             7  ######## m,           @####           ,s# ######## \\\n                                 |5 ######## #p       @####       ;# ######## 8\\\n                                     '7 ########  m,  @####  ,s@ ######## b7\n                                          l8 ######## #####  ####### WT`\n                                              |8 ############### B|\n                                                   7  ###### T\"\n */\n\n/**\n * ERRORS\n */\n\n/// @notice Unauthorized sender `sender`\n/// @param sender Transaction sender\nerror Unauthorized(address sender);\n/// @notice Invalid number of accounts `accountsLength`, must have at least 2\n/// @param accountsLength Length of accounts array\nerror InvalidSplit__TooFewAccounts(uint256 accountsLength);\n/// @notice Array lengths of accounts & percentAllocations don't match (`accountsLength` != `allocationsLength`)\n/// @param accountsLength Length of accounts array\n/// @param allocationsLength Length of percentAllocations array\nerror InvalidSplit__AccountsAndAllocationsMismatch(uint256 accountsLength, uint256 allocationsLength);\n/// @notice Invalid percentAllocations sum `allocationsSum` must equal `PERCENTAGE_SCALE`\n/// @param allocationsSum Sum of percentAllocations array\nerror InvalidSplit__InvalidAllocationsSum(uint32 allocationsSum);\n/// @notice Invalid accounts ordering at `index`\n/// @param index Index of out-of-order account\nerror InvalidSplit__AccountsOutOfOrder(uint256 index);\n/// @notice Invalid percentAllocation of zero at `index`\n/// @param index Index of zero percentAllocation\nerror InvalidSplit__AllocationMustBePositive(uint256 index);\n/// @notice Invalid distributionFee `distributionFee` cannot be greater than 10% (1e5)\n/// @param distributionFee Invalid distributionFee amount\nerror InvalidSplit__InvalidDistributionFee(uint32 distributionFee);\n/// @notice Invalid hash `hash` from split data (accounts, percentAllocations, distributionFee)\n/// @param hash Invalid hash\nerror InvalidSplit__InvalidHash(bytes32 hash);\n/// @notice Invalid new controlling address `newController` for mutable split\n/// @param newController Invalid new controller\nerror InvalidNewController(address newController);\n\n/**\n * @title SplitMain\n * @author 0xSplits <will@0xSplits.xyz>\n * @notice A composable and gas-efficient protocol for deploying splitter contracts.\n * @dev Split recipients, ownerships, and keeper fees are stored onchain as calldata & re-passed as args / validated\n * via hashing when needed. Each split gets its own address & proxy for maximum composability with other contracts onchain.\n * For these proxies, we extended EIP-1167 Minimal Proxy Contract to avoid `DELEGATECALL` inside `receive()` to accept\n * hard gas-capped `sends` & `transfers`.\n */\ncontract SplitMain is ISplitMain {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    /**\n     * STRUCTS\n     */\n\n    /// @notice holds Split metadata\n    struct Split {\n        bytes32 hash;\n        address controller;\n        address newPotentialController;\n    }\n\n    /**\n     * STORAGE\n     */\n\n    /**\n     * STORAGE - CONSTANTS & IMMUTABLES\n     */\n\n    /// @notice constant to scale uints into percentages (1e6 == 100%)\n    uint256 public constant PERCENTAGE_SCALE = 1e6;\n    /// @notice maximum distribution fee; 1e5 = 10% * PERCENTAGE_SCALE\n    uint256 internal constant MAX_DISTRIBUTION_FEE = 1e5;\n    /// @notice address of wallet implementation for split proxies\n    address public immutable override walletImplementation;\n\n    /**\n     * STORAGE - VARIABLES - PRIVATE & INTERNAL\n     */\n\n    /// @notice mapping to account ETH balances\n    mapping(address => uint256) internal ethBalances;\n    /// @notice mapping to account ERC20 balances\n    mapping(ERC20 => mapping(address => uint256)) internal erc20Balances;\n    /// @notice mapping to Split metadata\n    mapping(address => Split) internal splits;\n\n    /**\n     * MODIFIERS\n     */\n\n    /** @notice Reverts if the sender doesn't own the split `split`\n     *  @param split Address to check for control\n     */\n    modifier onlySplitController(address split) {\n        if (msg.sender != splits[split].controller) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    /** @notice Reverts if the sender isn't the new potential controller of split `split`\n     *  @param split Address to check for new potential control\n     */\n    modifier onlySplitNewPotentialController(address split) {\n        if (msg.sender != splits[split].newPotentialController) revert Unauthorized(msg.sender);\n        _;\n    }\n\n    /** @notice Reverts if the split with recipients represented by `accounts` and `percentAllocations` is malformed\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     */\n    modifier validSplit(\n        address[] memory accounts,\n        uint32[] memory percentAllocations,\n        uint32 distributionFee\n    ) {\n        if (accounts.length < 2) revert InvalidSplit__TooFewAccounts(accounts.length);\n        if (accounts.length != percentAllocations.length)\n            revert InvalidSplit__AccountsAndAllocationsMismatch(accounts.length, percentAllocations.length);\n        // _getSum should overflow if any percentAllocation[i] < 0\n        if (_getSum(percentAllocations) != PERCENTAGE_SCALE)\n            revert InvalidSplit__InvalidAllocationsSum(_getSum(percentAllocations));\n        unchecked {\n            // overflow should be impossible in for-loop index\n            // cache accounts length to save gas\n            uint256 loopLength = accounts.length - 1;\n            for (uint256 i = 0; i < loopLength; i++) {\n                // overflow should be impossible in array access math\n                if (accounts[i] >= accounts[i + 1]) revert InvalidSplit__AccountsOutOfOrder(i);\n                if (percentAllocations[i] == uint32(0)) revert InvalidSplit__AllocationMustBePositive(i);\n            }\n            // overflow should be impossible in array access math with validated equal array lengths\n            if (percentAllocations[loopLength] == uint32(0)) revert InvalidSplit__AllocationMustBePositive(loopLength);\n        }\n        if (distributionFee > MAX_DISTRIBUTION_FEE) revert InvalidSplit__InvalidDistributionFee(distributionFee);\n        _;\n    }\n\n    /** @notice Reverts if `newController` is the zero address\n     *  @param newController Proposed new controlling address\n     */\n    modifier validNewController(address newController) {\n        if (newController == address(0)) revert InvalidNewController(newController);\n        _;\n    }\n\n    /**\n     * CONSTRUCTOR\n     */\n\n    constructor() {\n        walletImplementation = address(new SplitWallet());\n    }\n\n    /**\n     * FUNCTIONS\n     */\n\n    /**\n     * FUNCTIONS - PUBLIC & EXTERNAL\n     */\n\n    /** @notice Receive ETH\n     *  @dev Used by split proxies in `distributeETH` to transfer ETH to `SplitMain`\n     *  Funds sent outside of `distributeETH` will be unrecoverable\n     */\n    receive() external payable {}\n\n    /** @notice Creates a new split with recipients `accounts` with ownerships `percentAllocations`, a keeper fee for splitting of `distributionFee` and the controlling address `controller`\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     *  @param controller Controlling address (0x0 if immutable)\n     *  @return split Address of newly created split\n     */\n    function createSplit(\n        address[] calldata accounts,\n        uint32[] calldata percentAllocations,\n        uint32 distributionFee,\n        address controller\n    ) external override validSplit(accounts, percentAllocations, distributionFee) returns (address split) {\n        bytes32 splitHash = _hashSplit(accounts, percentAllocations, distributionFee);\n        if (controller == address(0)) {\n            // create immutable split\n            split = Clones.cloneDeterministic(walletImplementation, splitHash);\n        } else {\n            // create mutable split\n            split = Clones.clone(walletImplementation);\n            splits[split].controller = controller;\n        }\n        // store split's hash in storage for future verification\n        splits[split].hash = splitHash;\n        emit CreateSplit(split);\n    }\n\n    /** @notice Predicts the address for an immutable split created with recipients `accounts` with ownerships `percentAllocations` and a keeper fee for splitting of `distributionFee`\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     *  @return split Predicted address of such an immutable split\n     */\n    function predictImmutableSplitAddress(\n        address[] calldata accounts,\n        uint32[] calldata percentAllocations,\n        uint32 distributionFee\n    ) external view override validSplit(accounts, percentAllocations, distributionFee) returns (address split) {\n        bytes32 splitHash = _hashSplit(accounts, percentAllocations, distributionFee);\n        split = Clones.predictDeterministicAddress(walletImplementation, splitHash);\n    }\n\n    /** @notice Updates an existing split with recipients `accounts` with ownerships `percentAllocations` and a keeper fee for splitting of `distributionFee`\n     *  @param split Address of mutable split to update\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     */\n    function updateSplit(\n        address split,\n        address[] calldata accounts,\n        uint32[] calldata percentAllocations,\n        uint32 distributionFee\n    ) external override onlySplitController(split) validSplit(accounts, percentAllocations, distributionFee) {\n        bytes32 splitHash = _hashSplit(accounts, percentAllocations, distributionFee);\n        // store new hash in storage for future verification\n        splits[split].hash = splitHash;\n        emit UpdateSplit(split);\n    }\n\n    /** @notice Begins transfer of the controlling address of mutable split `split` to `newController`\n     *  @dev Two-step control transfer inspired by [dharma](https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/helpers/TwoStepOwnable.sol)\n     *  @param split Address of mutable split to transfer control for\n     *  @param newController Address to begin transferring control to\n     */\n    function transferControl(address split, address newController)\n        external\n        override\n        onlySplitController(split)\n        validNewController(newController)\n    {\n        splits[split].newPotentialController = newController;\n        emit InitiateControlTransfer(split, newController);\n    }\n\n    /** @notice Cancels transfer of the controlling address of mutable split `split`\n     *  @param split Address of mutable split to cancel control transfer for\n     */\n    function cancelControlTransfer(address split) external override onlySplitController(split) {\n        delete splits[split].newPotentialController;\n        emit CancelControlTransfer(split);\n    }\n\n    /** @notice Accepts transfer of the controlling address of mutable split `split`\n     *  @param split Address of mutable split to accept control transfer for\n     */\n    function acceptControl(address split) external override onlySplitNewPotentialController(split) {\n        delete splits[split].newPotentialController;\n        emit ControlTransfer(split, splits[split].controller, msg.sender);\n        splits[split].controller = msg.sender;\n    }\n\n    /** @notice Turns mutable split `split` immutable\n     *  @param split Address of mutable split to turn immutable\n     */\n    function makeSplitImmutable(address split) external override onlySplitController(split) {\n        delete splits[split].newPotentialController;\n        emit ControlTransfer(split, splits[split].controller, address(0));\n        splits[split].controller = address(0);\n    }\n\n    /** @notice Distributes the ETH balance for split `split`\n     *  @dev `accounts`, `percentAllocations`, and `distributionFee` are verified by hashing\n     *  & comparing to the hash in storage associated with split `split`\n     *  @param split Address of split to distribute balance for\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     *  @param distributionAddress Address to pay `distributionFee` to\n     */\n    function distributeETH(\n        address split,\n        address[] memory accounts,\n        uint32[] memory percentAllocations,\n        uint32 distributionFee,\n        address distributionAddress\n    ) external override validSplit(accounts, percentAllocations, distributionFee) {\n        // use internal fn instead of modifier to avoid stack depth compiler errors\n        _validSplitHash(split, accounts, percentAllocations, distributionFee);\n        uint256 mainBalance = ethBalances[split];\n        uint256 proxyBalance = split.balance;\n        // leave balance of 1 in SplitMain for gas efficiency\n        // underflow if mainBalance + proxyBalance = 0 (no funds to split)\n        uint256 amountToSplit = mainBalance + proxyBalance - 1;\n        if (mainBalance != 1) ethBalances[split] = 1;\n        // emit event with gross amountToSplit (before deducting distributionFee)\n        emit DistributeETH(split, amountToSplit, distributionAddress);\n        if (distributionFee != 0) {\n            // given `amountToSplit`, calculate keeper fee\n            uint256 distributionFeeAmount = _scaleAmountByPercentage(amountToSplit, distributionFee);\n            unchecked {\n                // credit keeper with fee\n                // overflow should be impossible with validated distributionFee\n                ethBalances[\n                    distributionAddress != address(0) ? distributionAddress : msg.sender\n                ] += distributionFeeAmount;\n                // given keeper fee, calculate how much to distribute to split recipients\n                // underflow should be impossible with validated distributionFee\n                amountToSplit -= distributionFeeAmount;\n            }\n        }\n        unchecked {\n            // distribute remaining balance\n            // overflow should be impossible in for-loop index\n            // cache accounts length to save gas\n            uint256 accountsLength = accounts.length;\n            for (uint256 i = 0; i < accountsLength; i++) {\n                // overflow should be impossible with validated allocations\n                ethBalances[accounts[i]] += _scaleAmountByPercentage(amountToSplit, percentAllocations[i]);\n            }\n        }\n        // flush proxy ETH balance to SplitMain\n        // split proxy should be guaranteed to exist at this address after validating splitHash\n        // (attacker can't deploy own contract to address with high balance & empty sendETHToMain\n        // to drain ETH from SplitMain)\n        // could technically check if (change in proxy balance == change in SplitMain balance)\n        // before/after external call, but seems like extra gas for no practical benefit\n        if (proxyBalance > 0) SplitWallet(split).sendETHToMain(proxyBalance);\n    }\n\n    /** @notice Distributes the ERC20 `token` balance for split `split`\n     *  @dev `accounts`, `percentAllocations`, and `distributionFee` are verified by hashing\n     *  & comparing to the hash in storage associated with split `split`\n     *  @dev pernicious ERC20s may cause overflow in this function inside\n     *  _scaleAmountByPercentage, but results do not affect ETH & other ERC20 balances\n     *  @param split Address of split to distribute balance for\n     *  @param token Address of ERC20 to distribute balance for\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     *  @param distributionAddress Address to pay `distributionFee` to\n     */\n    function distributeERC20(\n        address split,\n        ERC20 token,\n        address[] memory accounts,\n        uint32[] memory percentAllocations,\n        uint32 distributionFee,\n        address distributionAddress\n    ) external override validSplit(accounts, percentAllocations, distributionFee) {\n        // use internal fn instead of modifier to avoid stack depth compiler errors\n        _validSplitHash(split, accounts, percentAllocations, distributionFee);\n        uint256 amountToSplit;\n        uint256 mainBalance = erc20Balances[token][split];\n        uint256 proxyBalance = token.balanceOf(split);\n        if (proxyBalance > 1) {\n            unchecked {\n                // leave balance of 1 in ERC20 for gas efficiency\n                // leave balances of 1 in SplitMain for gas efficiency\n                // overflow impossible with proxyBalance >= 2\n                amountToSplit = mainBalance + proxyBalance - 2;\n            }\n        } else {\n            // leave balances of 1 in SplitMain for gas efficiency\n            // underflow if erc20Balance is 0 & proxyBalance is 0 or 1 (no funds to split)\n            amountToSplit = mainBalance - 1;\n        }\n        // leave balance of 1 for gas efficiency\n        if (mainBalance != 1) erc20Balances[token][split] = 1;\n        // emit event with gross amountToSplit (before deducting distributionFee)\n        emit DistributeERC20(split, token, amountToSplit, distributionAddress);\n        if (distributionFee != 0) {\n            // given `amountToSplit`, calculate keeper fee\n            uint256 distributionFeeAmount = _scaleAmountByPercentage(amountToSplit, distributionFee);\n            // overflow should be impossible with validated distributionFee\n            unchecked {\n                // credit keeper with fee\n                erc20Balances[token][\n                    distributionAddress != address(0) ? distributionAddress : msg.sender\n                ] += distributionFeeAmount;\n                // given keeper fee, calculate how much to distribute to split recipients\n                amountToSplit -= distributionFeeAmount;\n            }\n        }\n        // distribute remaining balance\n        // overflows should be impossible in for-loop with validated allocations\n        unchecked {\n            // cache accounts length to save gas\n            uint256 accountsLength = accounts.length;\n            for (uint256 i = 0; i < accountsLength; i++) {\n                erc20Balances[token][accounts[i]] += _scaleAmountByPercentage(amountToSplit, percentAllocations[i]);\n            }\n        }\n        // split proxy should be guaranteed to exist at this address after validating splitHash\n        // (attacker can't deploy own contract to address with high ERC20 balance & empty\n        // sendERC20ToMain to drain ERC20 from SplitMain)\n        // could technically check if (change in proxy ERC20 balance == change in splitmain\n        // ERC20 balance) before/after external call, but seems like extra gas for no practical benefit\n        unchecked {\n            // flush proxy ERC20 balance to SplitMain\n            // leave balance of 1 in ERC20 for gas efficiency\n            // overflow is impossible in proxyBalance math\n            if (proxyBalance > 1) SplitWallet(split).sendERC20ToMain(token, proxyBalance - 1);\n        }\n    }\n\n    /** @notice Withdraw ETH &/ ERC20 balances for account `account`\n     *  @param account Address to withdraw on behalf of\n     *  @param eth Bool of whether to withdraw ETH\n     *  @param tokens Addresses of ERC20s to withdraw for\n     */\n    function withdraw(\n        address account,\n        bool eth,\n        ERC20[] calldata tokens\n    ) external override {\n        uint256 ethUint = eth ? 1 : 0;\n        unchecked {\n            // overflow should be impossible in array length math\n            uint256[] memory withdrawnAmounts = new uint256[](ethUint + tokens.length);\n            if (eth) {\n                withdrawnAmounts[0] = _withdraw(account);\n            }\n            // overflow should be impossible in for-loop index\n            for (uint256 i = 0; i < tokens.length; i++) {\n                // overflow should be impossible in array length math\n                withdrawnAmounts[ethUint + i] = _withdrawERC20(account, tokens[i]);\n            }\n            emit Withdrawal(account, eth, tokens, withdrawnAmounts);\n        }\n    }\n\n    /**\n     * FUNCTIONS - VIEWS\n     */\n\n    /** @notice Returns the current hash of split `split`\n     *  @param split Split to return hash for\n     *  @return Split's hash\n     */\n    function getHash(address split) external view returns (bytes32) {\n        return splits[split].hash;\n    }\n\n    /** @notice Returns the current controller of split `split`\n     *  @param split Split to return controller for\n     *  @return Split's controller\n     */\n    function getController(address split) external view returns (address) {\n        return splits[split].controller;\n    }\n\n    /** @notice Returns the current newPotentialController of split `split`\n     *  @param split Split to return newPotentialController for\n     *  @return Split's newPotentialController\n     */\n    function getNewPotentialController(address split) external view returns (address) {\n        return splits[split].newPotentialController;\n    }\n\n    /** @notice Returns the current ETH balance of account `account`\n     *  @param account Account to return ETH balance for\n     *  @return Account's balance of ETH\n     */\n    function getETHBalance(address account) external view returns (uint256) {\n        return ethBalances[account];\n    }\n\n    /** @notice Returns the ERC20 balance of token `token` for account `account`\n     *  @param account Account to return ERC20 `token` balance for\n     *  @param token Token to return balance for\n     *  @return Account's balance of `token`\n     */\n    function getERC20Balance(address account, ERC20 token) external view returns (uint256) {\n        return erc20Balances[token][account];\n    }\n\n    /**\n     * FUNCTIONS - PRIVATE & INTERNAL\n     */\n\n    /** @notice Sums array of uint32s\n     *  @param numbers Array of uint32s to sum\n     *  @return sum Sum of `numbers`.\n     */\n    function _getSum(uint32[] memory numbers) internal pure returns (uint32 sum) {\n        // overflow should be impossible in for-loop index\n        uint256 numbersLength = numbers.length;\n        for (uint256 i = 0; i < numbersLength; ) {\n            sum += numbers[i];\n            unchecked {\n                // overflow should be impossible in for-loop index\n                i++;\n            }\n        }\n    }\n\n    /** @notice Hashes a split\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     *  @return computedHash Hash of the split.\n     */\n    function _hashSplit(\n        address[] memory accounts,\n        uint32[] memory percentAllocations,\n        uint32 distributionFee\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(accounts, percentAllocations, distributionFee));\n    }\n\n    /** @notice Checks hash from `accounts`, `percentAllocations`, and `distributionFee` against the hash stored for `split`\n     *  @param split Address of hash to check\n     *  @param accounts Ordered, unique list of addresses with ownership in the split\n     *  @param percentAllocations Percent allocations associated with each address\n     *  @param distributionFee Keeper fee paid by split to cover gas costs of distribution\n     */\n    function _validSplitHash(\n        address split,\n        address[] memory accounts,\n        uint32[] memory percentAllocations,\n        uint32 distributionFee\n    ) internal view {\n        bytes32 hash = _hashSplit(accounts, percentAllocations, distributionFee);\n        if (splits[split].hash != hash) revert InvalidSplit__InvalidHash(hash);\n    }\n\n    /** @notice Multiplies an amount by a scaled percentage\n     *  @param amount Amount to get `scaledPercentage` of\n     *  @param scaledPercent Percent scaled by PERCENTAGE_SCALE\n     *  @return scaledAmount Percent of `amount`.\n     */\n    function _scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        internal\n        pure\n        returns (uint256 scaledAmount)\n    {\n        // use assembly to bypass checking for overflow & division by 0\n        // scaledPercent has been validated to be < PERCENTAGE_SCALE)\n        // & PERCENTAGE_SCALE will never be 0\n        // pernicious ERC20s may cause overflow, but results do not affect ETH & other ERC20 balances\n        assembly {\n            /* eg (100 * 2*1e4) / (1e6) */\n            scaledAmount := div(mul(amount, scaledPercent), PERCENTAGE_SCALE)\n        }\n    }\n\n    /** @notice Withdraw ETH for account `account`\n     *  @param account Account to withdrawn ETH for\n     *  @return withdrawn Amount of ETH withdrawn\n     */\n    function _withdraw(address account) internal returns (uint256 withdrawn) {\n        // leave balance of 1 for gas efficiency\n        // underflow is ethBalance is 0\n        withdrawn = ethBalances[account] - 1;\n        ethBalances[account] = 1;\n        account.safeTransferETH(withdrawn);\n    }\n\n    /** @notice Withdraw ERC20 `token` for account `account`\n     *  @param account Account to withdrawn ERC20 `token` for\n     *  @return withdrawn Amount of ERC20 `token` withdrawn\n     */\n    function _withdrawERC20(address account, ERC20 token) internal returns (uint256 withdrawn) {\n        // leave balance of 1 for gas efficiency\n        // underflow is erc20Balance is 0\n        withdrawn = erc20Balances[token][account] - 1;\n        erc20Balances[token][account] = 1;\n        token.safeTransfer(account, withdrawn);\n    }\n}\n"
    },
    "contracts/0xSplits/libraries/Clones.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\n/// @notice create opcode failed\nerror CreateError();\n/// @notice create2 opcode failed\nerror Create2Error();\n\nlibrary Clones {\n  /**\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`\n   * except when someone calls `receive()` and then it emits an event matching\n   * `SplitWallet.ReceiveETH(indexed address, amount)`\n   * Inspired by OZ & 0age's minimal clone implementations based on eip 1167 found at\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.3.0/contracts/proxy/Clones.sol\n   * and https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n   *\n   * This function uses the create2 opcode and a `salt` to deterministically deploy\n   * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n   * the clones cannot be deployed twice at the same address.\n   *\n   * init: 0x3d605d80600a3d3981f3\n   * 3d   returndatasize  0\n   * 605d push1 0x5d      0x5d 0\n   * 80   dup1            0x5d 0x5d 0\n   * 600a push1 0x0a      0x0a 0x5d 0x5d 0\n   * 3d   returndatasize  0 0x0a 0x5d 0x5d 0\n   * 39   codecopy        0x5d 0                      destOffset offset length     memory[destOffset:destOffset+length] = address(this).code[offset:offset+length]       copy executing contracts bytecode\n   * 81   dup2            0 0x5d 0\n   * f3   return          0                           offset length                return memory[offset:offset+length]                                                   returns from this contract call\n   *\n   * contract: 0x36603057343d52307f830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b160203da23d3df35b3d3d3d3d363d3d37363d73bebebebebebebebebebebebebebebebebebebebe5af43d3d93803e605b57fd5bf3\n   *     0x000     36       calldatasize      cds\n   *     0x001     6030     push1 0x30        0x30 cds\n   * ,=< 0x003     57       jumpi\n   * |   0x004     34       callvalue         cv\n   * |   0x005     3d       returndatasize    0 cv\n   * |   0x006     52       mstore\n   * |   0x007     30       address           addr\n   * |   0x008     7f830d.. push32 0x830d..   id addr\n   * |   0x029     6020     push1 0x20        0x20 id addr\n   * |   0x02b     3d       returndatasize    0 0x20 id addr\n   * |   0x02c     a2       log2\n   * |   0x02d     3d       returndatasize    0\n   * |   0x02e     3d       returndatasize    0 0\n   * |   0x02f     f3       return\n   * `-> 0x030     5b       jumpdest\n   *     0x031     3d       returndatasize    0\n   *     0x032     3d       returndatasize    0 0\n   *     0x033     3d       returndatasize    0 0 0\n   *     0x034     3d       returndatasize    0 0 0 0\n   *     0x035     36       calldatasize      cds 0 0 0 0\n   *     0x036     3d       returndatasize    0 cds 0 0 0 0\n   *     0x037     3d       returndatasize    0 0 cds 0 0 0 0\n   *     0x038     37       calldatacopy      0 0 0 0\n   *     0x039     36       calldatasize      cds 0 0 0 0\n   *     0x03a     3d       returndatasize    0 cds 0 0 0 0\n   *     0x03b     73bebe.. push20 0xbebe..   0xbebe 0 cds 0 0 0 0\n   *     0x050     5a       gas               gas 0xbebe 0 cds 0 0 0 0\n   *     0x051     f4       delegatecall      suc 0 0\n   *     0x052     3d       returndatasize    rds suc 0 0\n   *     0x053     3d       returndatasize    rds rds suc 0 0\n   *     0x054     93       swap4             0 rds suc 0 rds\n   *     0x055     80       dup1              0 0 rds suc 0 rds\n   *     0x056     3e       returndatacopy    suc 0 rds\n   *     0x057     605b     push1 0x5b        0x5b suc 0 rds\n   * ,=< 0x059     57       jumpi             0 rds\n   * |   0x05a     fd       revert\n   * `-> 0x05b     5b       jumpdest          0 rds\n   *     0x05c     f3       return\n   *\n   */\n  function clone(address implementation) internal returns (address instance) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(\n        ptr,\n        0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\n      )\n      mstore(\n        add(ptr, 0x13),\n        0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\n      )\n      mstore(\n        add(ptr, 0x33),\n        0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\n      )\n      mstore(add(ptr, 0x46), shl(0x60, implementation))\n      mstore(\n        add(ptr, 0x5a),\n        0x5af43d3d93803e605b57fd5bf300000000000000000000000000000000000000\n      )\n      instance := create(0, ptr, 0x67)\n    }\n    if (instance == address(0)) revert CreateError();\n  }\n\n  function cloneDeterministic(address implementation, bytes32 salt)\n    internal\n    returns (address instance)\n  {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(\n        ptr,\n        0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\n      )\n      mstore(\n        add(ptr, 0x13),\n        0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\n      )\n      mstore(\n        add(ptr, 0x33),\n        0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\n      )\n      mstore(add(ptr, 0x46), shl(0x60, implementation))\n      mstore(\n        add(ptr, 0x5a),\n        0x5af43d3d93803e605b57fd5bf300000000000000000000000000000000000000\n      )\n      instance := create2(0, ptr, 0x67, salt)\n    }\n    if (instance == address(0)) revert Create2Error();\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(\n    address implementation,\n    bytes32 salt,\n    address deployer\n  ) internal pure returns (address predicted) {\n    assembly {\n      let ptr := mload(0x40)\n      mstore(\n        ptr,\n        0x3d605d80600a3d3981f336603057343d52307f00000000000000000000000000\n      )\n      mstore(\n        add(ptr, 0x13),\n        0x830d2d700a97af574b186c80d40429385d24241565b08a7c559ba283a964d9b1\n      )\n      mstore(\n        add(ptr, 0x33),\n        0x60203da23d3df35b3d3d3d3d363d3d37363d7300000000000000000000000000\n      )\n      mstore(add(ptr, 0x46), shl(0x60, implementation))\n      mstore(\n        add(ptr, 0x5a),\n        0x5af43d3d93803e605b57fd5bf3ff000000000000000000000000000000000000\n      )\n      mstore(add(ptr, 0x68), shl(0x60, deployer))\n      mstore(add(ptr, 0x7c), salt)\n      mstore(add(ptr, 0x9c), keccak256(ptr, 0x67))\n      predicted := keccak256(add(ptr, 0x67), 0x55)\n    }\n  }\n\n  /**\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n   */\n  function predictDeterministicAddress(address implementation, bytes32 salt)\n    internal\n    view\n    returns (address predicted)\n  {\n    return predictDeterministicAddress(implementation, salt, address(this));\n  }\n}\n"
    },
    "contracts/0xSplits/ISplitMain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\n\n/**\n * @title ISplitMain\n * @author 0xSplits <will@0xSplits.xyz>\n */\ninterface ISplitMain {\n  /**\n   * FUNCTIONS\n   */\n\n  function walletImplementation() external returns (address);\n\n  function createSplit(\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee,\n    address controller\n  ) external returns (address);\n\n  function predictImmutableSplitAddress(\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee\n  ) external view returns (address);\n\n  function updateSplit(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee\n  ) external;\n\n  function transferControl(address split, address newController) external;\n\n  function cancelControlTransfer(address split) external;\n\n  function acceptControl(address split) external;\n\n  function makeSplitImmutable(address split) external;\n\n  function distributeETH(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee,\n    address distributionAddress\n  ) external;\n\n  function distributeERC20(\n    address split,\n    ERC20 token,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributionFee,\n    address distributionAddress\n  ) external;\n\n  function withdraw(\n    address account,\n    bool eth,\n    ERC20[] calldata tokens\n  ) external;\n\n  /**\n   * EVENTS\n   */\n\n  /** @notice emitted after each successful split creation\n   *  @param split Address of the created split\n   */\n  event CreateSplit(address indexed split);\n\n  /** @notice emitted after each successful split update\n   *  @param split Address of the updated split\n   */\n  event UpdateSplit(address indexed split);\n\n  /** @notice emitted after each initiated split control transfer\n   *  @param split Address of the split control transfer was initiated for\n   *  @param newPotentialController Address of the split's new potential controller\n   */\n  event InitiateControlTransfer(\n    address indexed split,\n    address indexed newPotentialController\n  );\n\n  /** @notice emitted after each canceled split control transfer\n   *  @param split Address of the split control transfer was canceled for\n   */\n  event CancelControlTransfer(address indexed split);\n\n  /** @notice emitted after each successful split control transfer\n   *  @param split Address of the split control was transferred for\n   *  @param previousController Address of the split's previous controller\n   *  @param newController Address of the split's new controller\n   */\n  event ControlTransfer(\n    address indexed split,\n    address indexed previousController,\n    address indexed newController\n  );\n\n  /** @notice emitted after each successful ETH balance split\n   *  @param split Address of the split that distributed its balance\n   *  @param amount Amount of ETH distributed\n   *  @param distributionAddress Address to credit distribution fee to\n   */\n  event DistributeETH(\n    address indexed split,\n    uint256 amount,\n    address indexed distributionAddress\n  );\n\n  /** @notice emitted after each successful ERC20 balance split\n   *  @param split Address of the split that distributed its balance\n   *  @param token Address of ERC20 distributed\n   *  @param amount Amount of ERC20 distributed\n   *  @param distributionAddress Address to credit distribution fee to\n   */\n  event DistributeERC20(\n    address indexed split,\n    ERC20 indexed token,\n    uint256 amount,\n    address indexed distributionAddress\n  );\n\n  /** @notice emitted after each successful withdrawal\n   *  @param account Address that funds were withdrawn to\n   *  @param eth Boolean for whether ETH was distributed\n   *  @param tokens Addresses of ERC20s distributed\n   *  @param amounts Amounts of ETH/ERC20 distributed (if ETH was distributed (`eth`),\n   *  will be first in the array Remaining array matches order of `tokens`)\n   */\n  event Withdrawal(\n    address indexed account,\n    bool eth,\n    ERC20[] tokens,\n    uint256[] amounts\n  );\n}\n"
    },
    "contracts/0xSplits/interfaces/ReverseRecords.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\ninterface ReverseRecords {\n  function getNames(address[] calldata addresses)\n    external\n    view\n    returns (string[] memory r);\n}\n"
    },
    "contracts/0xSplits/ReverseRecords.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\ninterface ReverseRecords {\n  function getNames(address[] calldata addresses)\n    external\n    view\n    returns (string[] memory r);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
